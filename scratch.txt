--- Hasbi nAllah hu wa naimal wakeel
create a customer class, and a stack of seats. customers remove seats and put them back in a concurrent fashion.
seat. has a position. x,y. and price.
cutomer has a name, and can request seats. and return seats.

write sync demo. create package for exercise.




- the number of seatsavailable should be synchronized. changing this number i mean.


-tree map
concurrent modification exception.
HashTable vs HashMap vs Concurrent HashMap all kinds of Map implementations
reading and deleting or adding to map



each seat has a compareTo method.
but that compare to method ALSO depends on a on outside variable that allows the comparison to happen more fairly.
if the customer is looking for 4 seats, we need to find a seat whose score is generated by the neighbors also.
otherwise if the customer is looking for 1 seat, the compare to method should just be determined by the seat's value.






hashmap/arraylist by rank of seat. neighbors. containing stacks of same rank seats. -> fine, but lots of moving parts i have to control. especially which
stack to remove from. that could be a pointer? that continually checks which (highest ranking) stack has stuff in it.

reserved seats go into a hashmap of customers.




PRIORITY QUEUE WAITLIST--------------------------------------------------------------
java.util.concurrent.ConcurrentLinkedQueue (JDK1.5, 1.6)
Both these Classes
Use fast atomic (java.util.concurrent.atomic package) methods for Add, Poll and Peek.
Use linked nodes that the queue re-links after polling thereby averting all reordering. Simple and fast.

do the neigborsh last. they are tricky. cuz the rank/score changes dynamically. (only consider neighbors in your own rank bucket. only look out of the bucket if no more elements in the bucket.

atomicinteger incrementAndGet. 40:37 Combining concurrency and collections.



